apiVersion: v1
kind: ConfigMap
metadata:
  name: health-monitor-scripts
  labels:
    app: health-monitor
data:
  system-health-monitor-cross.sh: |
    #!/bin/sh
    # Simplified cross-platform health monitor for containerized environments
    
    set -euo pipefail
    
    # Configuration from environment
    CPU_THRESHOLD=${CPU_THRESHOLD:-80}
    MEMORY_THRESHOLD=${MEMORY_THRESHOLD:-80}
    DISK_THRESHOLD=${DISK_THRESHOLD:-85}
    
    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
    
    # Detect OS
    if [ "$(uname)" = "Darwin" ]; then
        OS="macos"
    elif [ "$(uname)" = "Linux" ]; then
        OS="linux"
    else
        OS="unknown"
    fi
    
    log_message() {
        local level=$1
        local message=$2
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] [$level] $message"
    }
    
    check_cpu() {
        local cpu_usage
        
        if [ "$OS" = "macos" ]; then
            cpu_usage=$(top -l 1 | grep "CPU usage" | awk '{print $3}' | sed 's/%//')
        elif [ "$OS" = "linux" ]; then
            # Use /proc/loadavg for simpler CPU check in containers
            local load1=$(cat /proc/loadavg | awk '{print $1}')
            cpu_usage=$(echo "$load1 * 100" | bc -l 2>/dev/null || echo "0")
        else
            cpu_usage="0"
        fi
        
        cpu_usage=${cpu_usage%.*}
        
        if [ "$cpu_usage" -gt "$CPU_THRESHOLD" ]; then
            log_message "ALERT" "CPU usage is ${cpu_usage}% (threshold: ${CPU_THRESHOLD}%)"
            return 1
        else
            log_message "INFO" "CPU usage: ${cpu_usage}%"
            return 0
        fi
    }
    
    check_memory() {
        local mem_percent
        
        if [ "$OS" = "linux" ]; then
            # Use /proc/meminfo for container environments
            local total_mem=$(grep MemTotal /proc/meminfo | awk '{print $2}')
            local free_mem=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
            if [ -z "$free_mem" ]; then
                free_mem=$(grep MemFree /proc/meminfo | awk '{print $2}')
            fi
            local used_mem=$((total_mem - free_mem))
            mem_percent=$((used_mem * 100 / total_mem))
        else
            mem_percent="0"
        fi
        
        if [ "$mem_percent" -gt "$MEMORY_THRESHOLD" ]; then
            log_message "ALERT" "Memory usage is ${mem_percent}% (threshold: ${MEMORY_THRESHOLD}%)"
            return 1
        else
            log_message "INFO" "Memory usage: ${mem_percent}%"
            return 0
        fi
    }
    
    check_disk() {
        local disk_usage
        disk_usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
        
        if [ "$disk_usage" -gt "$DISK_THRESHOLD" ]; then
            log_message "ALERT" "Disk usage is ${disk_usage}% (threshold: ${DISK_THRESHOLD}%)"
            return 1
        else
            log_message "INFO" "Disk usage: ${disk_usage}%"
            return 0
        fi
    }
    
    check_processes() {
        local total_processes
        total_processes=$(ps aux | wc -l)
        log_message "INFO" "Total processes: $total_processes"
        return 0
    }
    
    run_health_checks() {
        local alerts=0
        
        echo "Starting container health monitoring..."
        log_message "INFO" "Container health monitoring started (OS: $OS)"
        
        echo "=== Container Health Checks ==="
        
        if ! check_cpu; then alerts=$((alerts + 1)); fi
        if ! check_memory; then alerts=$((alerts + 1)); fi
        if ! check_disk; then alerts=$((alerts + 1)); fi
        if ! check_processes; then alerts=$((alerts + 1)); fi
        
        echo "=== Summary ==="
        if [ "$alerts" -eq 0 ]; then
            echo "Container health: OK"
            log_message "INFO" "All container health checks passed"
        else
            echo "Container health: $alerts alert(s)"
            log_message "ALERT" "$alerts container health check(s) failed"
        fi
        
        return $alerts
    }
    
    run_health_checks
  k8s-app-health-checker.py: |
    #!/usr/bin/env python3
    # Simplified Kubernetes health checker for containerized environments
    
    import urllib.request
    import urllib.error
    import time
    import sys
    import json
    import os
    import subprocess
    from datetime import datetime
    
    class SimpleK8sHealthChecker:
        def __init__(self, base_url, timeout=10):
            self.base_url = base_url.rstrip('/')
            self.timeout = timeout
            self.namespace = os.environ.get('NAMESPACE', 'default')
            self.app_name = os.environ.get('APP_NAME', 'wisecow')
        
        def check_http_connectivity(self):
            try:
                start_time = time.time()
                request = urllib.request.Request(self.base_url, headers={'User-Agent': 'K8sHealthChecker/1.0'})
                with urllib.request.urlopen(request, timeout=self.timeout) as response:
                    response_time = time.time() - start_time
                    return True, str(response.status), response_time
            except Exception as e:
                return False, str(e), 0.0
        
        def check_k8s_pod_status(self):
            try:
                cmd = ['kubectl', 'get', 'pods', '-l', f'app={self.app_name}', '-n', self.namespace, '-o', 'json']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                if result.returncode != 0:
                    return {'status': 'KUBECTL_ERROR', 'error': result.stderr}
                
                pod_data = json.loads(result.stdout)
                pods = pod_data.get('items', [])
                
                ready_pods = 0
                for pod in pods:
                    for condition in pod['status'].get('conditions', []):
                        if condition['type'] == 'Ready' and condition['status'] == 'True':
                            ready_pods += 1
                            break
                
                return {
                    'status': 'SUCCESS',
                    'total_pods': len(pods),
                    'ready_pods': ready_pods
                }
            except Exception as e:
                return {'status': 'ERROR', 'error': str(e)}
        
        def run_check(self):
            print(f"Checking {self.app_name} in namespace {self.namespace}")
            
            # HTTP check
            http_success, http_status, response_time = self.check_http_connectivity()
            print(f"HTTP Connectivity: {'✓' if http_success else '✗'} ({http_status})")
            
            # K8s pod check
            pod_status = self.check_k8s_pod_status()
            if pod_status.get('status') == 'SUCCESS':
                total = pod_status.get('total_pods', 0)
                ready = pod_status.get('ready_pods', 0)
                print(f"Pod Status: {ready}/{total} pods ready")
            else:
                print(f"Pod Status: ERROR - {pod_status.get('error', 'Unknown')}")
            
            # Overall assessment
            overall_healthy = http_success and pod_status.get('ready_pods', 0) > 0
            print(f"Overall Health: {'HEALTHY' if overall_healthy else 'UNHEALTHY'}")
            
            return overall_healthy
    
    if __name__ == '__main__':
        app_url = os.environ.get('APP_URL', 'http://wisecow-service:80')
        checker = SimpleK8sHealthChecker(app_url)
        healthy = checker.run_check()
        sys.exit(0 if healthy else 1)
